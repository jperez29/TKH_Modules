1) Whenever you type a letter on a keyboard, a computer interprets this signal from the keyboard as a code, 
since every key produces a code. A computer then follows a series of steps: it finds and recognizes a 
letter as a font from its memory. Since letters are made up of lines and circles, a computer also needs
to recognize the corresponding combinations that create specific letters. The memory of a computer that 
manages the screen then holds a little box of pixels with the lines and circles of the letter that was 
pressed on the keyboard.  

2) Computers use input and output to create experiences by taking a user’s input, processing this information, 
and converting it to computer language in order to have a response from the computer to the user. For example, 
when you speak to Siri, the input is the words spoken to Siri, which Siri cannot understand. Siri breaks down 
your words to text, which then recognizes them as symbols and compares those symbols to the symbols in its database. 
Another example is scanning products at a grocery store. The input is the code on the product, and the computer 
compares the code to something it understands to get an output to the user, the output being the price of the item 
of purchase.

3) Software is infinitely reproducible because it is possible to create, sell, and use infinite copies of it and 
software is nothing because it is not a physical thing This contrasts with oil, for example, which is a finite
 something that cannot be reproduced. 

4) Code becomes software when it goes through a compiler, which is a software that transforms source code into 
machine code, or a list of instructions in binary that a computer understands. Once code is passed to the compiler, 
the compiler divides the text up into individual tokens, so that the computer can read and transform the code 
character by character. These tokens are then organized into a tree where the computer looks for functions and 
arguments. The final step is to convert the information from the tree to machine code that can do the same thing 
as the code provided to the compiler.

5) An algorithm is a process (or a sequence of steps) that achieves an outcome. One example I read about is in the 
book Weapons of Math Destruction (How Big Data Increases Inequality and Threatens Democracy); The book featured an 
algorithm for student loans. That process involves applicant screening, which includes looking at that individual’s 
background, including zip code. The outcome (or the thing that the algorithm achieves) is a decision on whether the 
individual should be granted a student loan. The author cautions that sometimes social biases could be ingrained in 
algorithms and that seemingly neutral computers can exacerbate inequality. For example, a student could be denied a 
loan based on their zip code. 

6) DRY principle stands for Don’t Repeat Yourself and its main goal in programming is to avoid code duplication. 
It means you should not repeat something more than once when you can let a computer repeat itself. On my own 
initiative I got my hands on a couple of practice datasets. I read them through Python, named those objects once, 
and moved on to reading in other datasets. This allowed me to avoid repetition when naming datasets.

7) Object-oriented programming is like manipulating play-doh. A programmer can take two pieces of play-doh 
(or two objects like datasets), stack or merge them together with code. So two distinct objects now become one 
separate object. The programmer can also add an additional variable (another smaller object) to the combined object. 
Like the article mentions, object-oriented programming is a sort of filing system because it keeps track of these 
objects, their names, and manipulations done to those objects.

8) Data is information that can be collected about things. Data can be the number of times a user logs into a social 
media platform, the miles someone runs in a week, and information collected at research labs from experiments. Code 
helps to organize, process, clean, and analyze the huge amount of data that is being generated by computers.

9) Debugging is troubleshooting. It is the practice of removing bugs from a program or code so that the program runs 
successfully. For example, during the pre-work technical assessments, I had to troubleshoot and fix my code - by correcting 
my use of semicolons, for example - so that it ran properly and so that it accomplished the things it needed to accomplish.

10) Frameworks offer a foundation when developing new applications and have components or pre-written code libraries that 
can be reused, helping developers to not reinvent the wheel. Frameworks can be thought of as templates that have elements 
that can aid in the software development process. It’s useful to use frameworks when developing apps at first since it could 
save time. You also won’t be repeating yourself since foundations have already been built, therefore following the DRY 
principle. The downside to using frameworks is that a developer is limited to what she or he can do because frameworks are built for 
specific purposes.

11) 
 I want to code because I want to solve public health and bioinformatics problems through programming - which includes cleaning 
and processing data on a particular issue, analyzing it, and generating useful knowledge. Not only would I enjoy the end result 
(the useful knowledge from data), but I would also enjoy the process to get there - for example, thinking about the goals of a 
program, how to structure code logically and efficiently so I do not repeat myself,  debugging where necessary, and manipulating 
and analyzing data. 

 I want to prepare myself for a career in an increasingly data-driven field of bioinformatics. Bioinformatics-related applications 
include analyzing DNA sequencing to understand the functions of new sequences of DNA by comparing them to genes of known  functions, 
analyzing proteomics data to understand the function of proteins that are produced by the cell, and processing genomic data from
pathogens and patients. Coding can help me to learn how to think about large-scale biological data in order to obtain meaningful 
information, which could also be used for public health practice.

 Additionally, I volunteered in a Molecular Pathology laboratory at Mount Sinai Hospital last year where I learned about the technologies
used for clinical purposes. One of the technologies I learned about was Next-Generation Sequencing (NGS) used to analyze DNA sequences. 
I got the opportunity to learn about how NGS is run in the lab and the biology foundation in every step, but I did not get to see the 
analysis of the data. Learning how to code would give me the ability to analyze the genomic data obtained from NGS and contribute to genetics.

 Finally, I have been learning how to code in Python for the past couple of months through Codecademy. I got a chance to learn about Python 
syntax and for and while loops, else-if statements, functions, dictionaries, among other concepts. While learning how to code, I have enjoyed 
not only learning about concepts in Python, but also putting them to practice through the many mini-projects in Codecademy, one of them being 
building Battleship.















